<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy con p5 Js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/neataptic/1.4.7/neataptic.js"></script>
    <script>
        let bird, bg, pipeTop, pipeBottom;
        let birdY = 250; //posición vertical inicial del pajaro
        let velocity = 0; //velocidad del pajaro en cada fotograma
        let gravity = 0.6; //fuerza d gravedad q afecta al pajaro
        let jumpPower = -10; //fuerza del salto del pajaro
        let pipes = []; //array para almacenar las tuberias
        let pipeGap = 150; //espacio entre pipes
        let pipeSpeed = 2; //la velocidad d movimiento d las pipes
        let lastPipeX; //ult posicion x de las pipes para calcular la siguiente
        let neat; //instancia neat para el aprendizaje automatico

        //funcion preload() es propia de p5 js y se ejecuta antes d inciar el juego
        // para encargarse de cargar los assets
        function preload() {
            //cargamos las imgs
            bg = loadImage('background.png');
            bird = loadImage('flappy.png');
            pipeTop = loadImage('pipe_top.png');
            pipeBottom = loadImage('pipe_bottom.png');
        }

        //la función setup() se ejecuta una vez al inicio del juego
        function setup() {
            createCanvas(500, 600); //creamos el canvas

            //inicializa neat con una red d 5 entradas y 1 salida
            neat = new neataptic.Neat(5, 1, {
                mutationRate: 0.3, //probabilidad d mutación en cada generación
                popSize: 50, //tamaño d la población de redes neuronales
                elitism: 5, //cantidad d individuos q se preservan sin cambios
                mutationAmount: 2 //cantidad d mutaciones aplicadas a cada individuo
            });

            resetGame(); //reinicia el juego y configura los agentes
        }

        //la funcion draw se ejecuta en bucle para actualizar el juego constantemente
        function draw() {
            background(bg); //dibujamos el fondo en cada fotograma
            console.log('Pipes: ', pipes.length);

            //Dibujamos y actualizamos los pipes
            for( let i = pipes.length - 1; i>= 0; i--) {
                pipes[i].move(); //movemos pipes a la izq
                pipes[i].show(); //dibuja la pipe en la nueva posicion

                //eliminamos los pipes q estan fuera d la pantalla
                if(pipes[i].offScreen()) {
                    pipes.splice(i, 1);
                }
            }

            //añadimos nuevos pipes cada x tiempo con un gap uniforme
            if(frameCount % 90 == 0) {
                //comprueba si hay o no pipes para utilizar un valor u otro
                let lastX = pipes.length > 0 ? pipes[pipes.length - 1].x : width;
                pipes.push(new Pipe(lastX)); //cada 90s se añaden nuevos pipes
            }

            //variable para verificar q todos los flappy estan muertooos
            let allDead = true;
            for(let genome of neat.population) {
                let bird = genome.bird;

                //comprueba la prop para ver si esta vivo
                if(!bird.dead) {
                    allDead = false;
                    bird.update();//actualiza la posicion del flappy
                    bird.show();//dibuja el flappy en la pantalla
                }
            }

            if(allDead) {
                nextGeneration();
            }

            //aplica la gravedad a flappy
            velocity += gravity; //la velocidad aumenta con la gravedad
            birdY += velocity; //la posicion del flappy se actualiza con la velocidad

            //evita q el flappy caiga fuera d la pantalla
            if (birdY > height - 30) {
                birdY = height - 30; //coloca al flappy en el suelo
                velocity = 0; //detiene su movimiento
            }
        }

        //funcion q reinicia el juego, reseteando las pipes y asignando nuevos flappys a la pop
        function resetGame() {
            pipes = []; //limpiamos array
            lastPipeX = width; //reinicia la posicion d la ult pipe

            for(let genome of neat.population) {
                genome.dead = false;//reiniciamos el estado d vivo d los flappys
                genome.score = 0;//reinicia puntuacion
                genome.bird = new Bird(genome);//crea un nuevo flappy para cada individuo
            }

            pipes.push(new Pipe(lastPipeX));//añade la pipe inicial
        }

        //funcion q genera una nueva gen con el algoritmo evolutivo
        function nextGeneration() {
            neat.evolve(); //evoluciona la pop usando neat
            resetGame(); //reinicia el juego con la nueva generación
        }

        class Pipe {
            constructor(lastX) {
                this.x = lastX + 200; //inicializa el pipe en el borde derecho d la pantalla
                this.top = random(100, height - pipeGap - 100); //altura aleatoria para el pipe top
                this.bottom = this.top + pipeGap; //calcula la posicion del pipe bottom
            }

            //mueve el pipe a la izq
            move() {
                this.x -= pipeSpeed;
            }

            //dibuja el pipe en la pantalla
            show() {
            /*
            Dibujamos la img de flappy en la posicion actual
            image(img, x, y, ancho, alto)
            - pipe: img de la pipe cargada en preload()
            - x: posicion en el eje x, fija en esta coordenada
            - this.top - pipeTop.height | this.bottom: posicion en el eje y,
                q cambia debido a la gravedad y los saltos
            - 50: ancho d la img en px
            - pipe.height: alto d la img en px
            */
                image(pipeTop, this.x, this.top - pipeTop.height, 50, pipeTop.height);
                image(pipeBottom, this.x, this.bottom, 50, pipeBottom.height);
            }

            //verifica si el pipe se ha salido d la pantalla (al completo)
            offScreen() {
                // -50 xq es el aancho del pipe
                return this.x < -50; //true si el pipe ha salido
            }

        }

        class Bird {
            constructor(genome) {
                this.x = 100; //posicion x inicial del flappy
                this.y = 250; //posicion y inicial del flappy
                this.velocity = velocity; //velocidad vertical inicial
                this.gravity = gravity; //gravedad q afecta al flappy
                this.jumpPower = jumpPower; //fuerza con la q el flappy salta
                this.brain = genome; //asigna la red neuronal al flappy
            }

            update() {
                this.velocity += this.gravity; //aplicamos la gravedad
                this.y += this.velocity; //actualiza la posicion vertical

                let inputs = this.getInputs(); //obtiene los datos de entrada para la IA
                let output = this.brain.activate(inputs); //activa la red neuronal con los inputs

                //si el output d la red neuronal es mayor a 0.5 el flappy salta
                if(output[0] > 0.5) {
                    this.velocity = this.jumpPower;
                }

                this.checkCollision(); //verifica si el flappy colisiona con los limites del canvas
            }

            getInputs() {
                let closestPipe = pipes.find( p => p.x > this.x) || pipes[0];

                return [
                    this.y / height, //valor normalizado d la posicion vertical del flappy
                    this.velocity / 10, //valor normalizado d la velocidad
                    closestPipe.x / width, //valor normalizado de la pipe + cercana
                    closestPipe.top / height, //valor normalizado de la posicion superior de la pipe
                    closestPipe.bottom / height//valor normalizado de la posicion inferior de la pipe
                ];
            }

            checkCollision() {
                //si toca el borde superior o inferior
                if(this.y > height || this.y < 0) {
                    this.dead = true;
                    return;
                }

                //verificamos la colisión con cada pipe
                for(let pipe of pipes) {
                    //comprueba si el flappy se encuentra en el espacio ocupado por las pipes (x, y)
                    if( this.x + 40 > pipe.x && this.x < pipe.x +50 
                        && (this.y < pipe.top || this.y + 30 > pipe.top)
                    ) {
                        this.dead = true;
                        return;
                    }
                }
            }

            //funcionq muestra el flappy en la pantalla
            show() {
                image(bird, this.x, this.y, 40, 30);
            }
        }

    </script>
</body>
</html>